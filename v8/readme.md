##  Движок JS решает задачи

- Работа с кучей (heap) и стэком вызовов
- Работа с памятью (выделение и сбор мусора)
- Компиляция JS в машинный код
- Оптимизация (Скрытые классы, кэш и прочее)

Event loop не является частью движка. Он является частью среды - браузера или nodejs.

#### Движки в средах:
- Chrome - v8
- Nodejs - v8

        Но устройство цикла событий разное, т.к. среды разные

### Стэк

Стэк вызовов исполняет инструкции. 
- Простые инструкции - помещаются и сразу выполняются. 
- Инструкции, основанные на вложенных коллбэках помещаются в стэк, доходят до последнего уровня вложенности, затем исполняются очищая стэк вызова, по приниципу Последний зашел, Первый вышел LIFO.

#### Приоритеты стэка

- Функция 3 // Выполнится первой 
- Функция 2 // Выполнится второй 
- Функция 1 // Выполнится третьей

## Очередь задач

Очередь задач - помещает сюда коллбэки отложенных функций по принципу Первый зашел, Первый вышел FIFO. Затем при очищении стэка - помещают эти коллбэки в стек, уходя из очереди.

#### Приоритеты очереди 

- Функуия 1 // Выполнится первой 
- Функция 2 // Выполнится второй
- Функция 3 // Выполнится третьей

**Движок JS - предоставляет call stack, а очередь задач предоставляет Event Loop**

[Стэк и куча](https://okusov.ru/javascript-stek-i-kucha)

### Стек
Стек нужен для хранения значений переменных запущенной функции. Состоит он из фреймов, где каждому фрейму соотносится запущенная функция.

*Стек в ОЗУ соотносится со структурой данных "стек", работает по принципу LIFO (Last In, First Out), а его размер равен 1 мегабайту. Когда запускается функция, она записывается в стек и даже без наличия переменных внутри функции, будет занимать определенное место в стеке. Очень часто при бесконечной рекурсии на JS можно встретить в консоли сообщение Maximum call stack size exceeded error. Оно говорит о том, что наш стек при последовательных вызовах функции попросту заполнился.*

### Куча
В отличие от стека куча не имеет ограничений по размеру и может увеличиваться при необходимости. В куче хранятся все не примитивные значения (массивы, хэш-таблицы, классы и так далее).

*В JS нам не нужно как-то управлять состоянием кучи, за нас это делает сборщик мусора. Однако в C++ его нет, поэтому программистам приходится самим управлять памятью своего приложения, это позволяет лучше поработать над оптимизацией, но при этом увеличивает нагрузку на разработчика и перекладывает на него все риски в виде утечек памяти.*

## WEB Api

У браузера есть Web API. Он является инструментом для отработки асинхронных функций в том числе, но помимо этого выполняет ряд задач для работы с DOM, картинками, аудио, видео, 3D-графикой. 

Нам интересна работа асинхронных функций. 

К ним относятся:
- Слушатели событий
- Promises
- SetTimeout
- XMLHttpRequest
- Fetch и многие другие

Когда код видит инструкции, связанные с обращением к WEB Api - он помещает инструкцию в стэк, исполняет ее. Если попадается инструкция, которую необходимо выполнить через WebApi - она туда помещается.

Так например:
- setTimeout поместиться в WebApi.
- WebApi запустит счетчик на отработку указанной задержки
- После выполнения задержки, коллбэк, который был заложен в метод setTimeout поместится в очередь задач (макрозадач), предоставляемый Event Loop'ом
- При пустом стеке - задача из очереди поместится в стек и будет выполена

*Будет выполнена первая задача из очереди, затем все последующие по принципу FIFO*

### Например, рассмотрим setTimeout

        console.log(1); // Сразу поместится в стек, выполнится

        setTimeout( // Отправится в WebApi на исполнение задержки 1 с.
            () => { // По истечению 1 с. поместит колбэк в очередь 
                // При пустом стеке - поместит колбэек в стек
                // Выполнится из стека, очистив его
                console.log('timeout');
            },
            1000
        );

        console.log(2); // Сразу поместится в стек, выполнится

Таким образом, порядок выполнения будет следующий:
1. 1
2. 2
3. timeout - спустя 1 секунду

### Слушатели событий

1. Регистрируем событие в WEB API

        button1.addEventListener('click', (event) => {
            console.log(event);
        });
2. При срабатывании события колбэк помещается в очередь
        (event) => {
            console.log(event);
        }
3. Event Loop ожидает пустой стэк вызовов, как только он очистился от других задач из стэка - помещает колбэк в стэк
4. Исполняет коллбэк, помещая содержимое колбэка в стэк
5. Исполняет содержимое колбэка, очищая свой контекст
6. Очищает контекст колбэка из стэка

## Promise

С помощью промисов мы можем запускать асинхронный код, который не будет блокировать основной поток.

## Очереди задач

У очередей есть определенный приоритет. Event Loop берет задачи в соответствие с ним. В первую очередь всегда выполняются Microtasks.

### Очередь событий - Macrotask queue

        setTimeout(() => {
            console.log('timeout');
        }, 0);

### Очередь задач - Microtask queue

`Promises` всегда попадают в очередь Microtask.

        Promise.resolve().then(() => {
            console.log('microtask');
        });

После того как выполнятся все синхронные функции, произойдет следующее:

- WebApi отработает задержку в 0 с, и поместит коллбэк в очередь `макрозадач`
- Promise будет находится в очереди `микрозадач`
- Сначала поместиться в стэк и выполнится микрозадача, а именно коллбэк, который передается в then
- Затем будет выполнена макрозадача - колбэк из setTimeout

## Виды задач

### Синхронные задачи

Синхронные задачи включают в себя любые операции, которые выполняются последовательно и блокируют исполнение кода до их завершения. Вот некоторые общие примеры синхронных задач:
- Операции в цикле:
- Математические операции:
- Функции без асинхронных операций:
- Синхронные запросы к базе данных или файловой системе: fetchDataSync()
- Обработка данных: forEach
- Управление потоком выполнения: if else

 *Эти примеры демонстрируют синхронные задачи, которые выполняются последовательно и не ожидают завершения каких-либо асинхронных операций. Важно помнить, что в асинхронных средах, таких как веб-браузер или Node.js, выполнение синхронных задач может быть блокировано другими асинхронными операциями, такими как обработка событий или выполнение микрозадач.*

### Макрозадачи

Макрозадачи включают в себя более крупные блоки кода, обрабатываемые в цикле событий. Эти блоки кода могут включать в себя скрипты, события ввода пользователя и другие асинхронные операции. Вот некоторые примеры макрозадач:

- Выполнение скрипта:

        console.log("Step 1");
        // Блок кода, включающий в себя асинхронные операции
        console.log("Step 2");

- Обработка событий ввода пользователя:

        document.addEventListener('click', function() {
            console.log("User clicked");
        });

- Асинхронные запросы к серверу:

        fetch('https://api.example.com/data')
        .then(response => response.json())
        .then(data => console.log(data));

- Анимации:

        const element = document.getElementById('animatedElement');
        element.style.transition = 'transform 1s ease-in-out';
        element.style.transform = 'translateX(100px)';

- Таймеры:

        setTimeout(function() {
        console.log("Timeout completed");
        }, 2000);

- Использование библиотек и фреймворков:
    Многие библиотеки и фреймворки, такие как React, Angular или Vue, могут включать в себя обработку макрозадач при изменении состояния компонентов.

*В этих примерах макрозадачи представляют собой более крупные блоки кода, которые добавляются в очередь задач и выполняются в цикле событий по мере их доступности.*

### Микрозадачи

На 99% это всегда промисы.

Микрозадачи в основном связаны с выполнением промисов (Promises) и представляют собой небольшие задачи, которые обрабатываются в цикле событий после завершения текущей задачи, но перед выполнением следующей макрозадачи. Вот несколько примеров микрозадач:

- Обработка промисов:

        const promise = new Promise((resolve, reject) => {
        // Асинхронный код
        resolve('Data loaded successfully');
        });

        promise.then((data) => {
        console.log(data);
        });

- Обработка событий анимации:
*В некоторых случаях, события анимации также могут генерировать микрозадачи.*

        const element = document.getElementById('animatedElement');
        element.addEventListener('animationend', function() {
        console.log('Animation completed');
        });

- Микрозадачи внутри макрозадач:
*Внутри макрозадач (например, выполнение скрипта или обработка события) могут быть добавлены обработчики, которые создают и обрабатывают микрозадачи.*

        console.log("Step 1");

        setTimeout(function() {
        console.log("Step 2");

        Promise.resolve().then(function() {
            console.log("Microtask inside macrotask");
        });
        }, 1000);

- Микрозадачи внутри промисов:
*Промисы могут сами генерировать микрозадачи.*

        const promise = new Promise((resolve, reject) => {
        resolve('Data loaded successfully');
        });

        promise.then((data) => {
        console.log(data);

        return Promise.resolve('Additional data');
        }).then((additionalData) => {
        console.log(additionalData);
        });

- Микрозадачи внутри async/await:
*Оператор await в функции, помеченной как async, также может создавать микрозадачи.*

        async function example() {
        const result = await someAsyncFunction();
        console.log(result);
        }

*Все эти примеры иллюстрируют сценарии, где микрозадачи играют роль в обработке асинхронных операций и взаимодействии с циклом событий.*

### Порядок исполнения задач

1. Выполняются все синхронные задачи
2. Выполняются все микрозадачи
3. Выполняется 1 макрозадача
4. Выполняются все микрозадачи, порожденные 1 макрозадачей
5. Выполняется 2 макрозадача
6. Выполняются все микрозадачи, порожденные 2 макрозадачей