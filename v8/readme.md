##  Движок JS решает задачи

- Работа с кучей (heap) и стэком вызовов
- Работа с памятью (выделение и сбор мусора)
- Компиляция JS в машинный код
- Оптимизация (Скрытые классы, кэш и прочее)

Event loop не является частью движка. Он является частью среды - браузера или nodejs.

#### Движки в средах:
- Chrome - v8
- Nodejs - v8

        Но устройство цикла событий разное, т.к. среды разные

### Стэк

Стэк вызовов исполняет инструкции. 
- Простые инструкции - помещаются и сразу выполняются. 
- Инструкции, основанные на вложенных коллбэках помещаются в стэк, доходят до последнего уровня вложенности, затем исполняются очищая стэк вызова, по приниципу Последний зашел, Первый вышел LIFO.

#### Приоритеты стэка

- Функция 3 // Выполнится первой 
- Функция 2 // Выполнится второй 
- Функция 1 // Выполнится третьей

## Очередь задач

Очередь задач - помещает сюда коллбэки отложенных функций по принципу Первый зашел, Первый вышел FIFO. Затем при очищении стэка - помещают эти коллбэки в стек, уходя из очереди.

#### Приоритеты очереди 

- Функуия 1 // Выполнится первой 
- Функция 2 // Выполнится второй
- Функция 3 // Выполнится третьей

**Движок JS - предоставляет call stack, а очередь задач предоставляет Event Loop**

[Стэк и куча](https://okusov.ru/javascript-stek-i-kucha)

### Стек
Стек нужен для хранения значений переменных запущенной функции. Состоит он из фреймов, где каждому фрейму соотносится запущенная функция.

*Стек в ОЗУ соотносится со структурой данных "стек", работает по принципу LIFO (Last In, First Out), а его размер равен 1 мегабайту. Когда запускается функция, она записывается в стек и даже без наличия переменных внутри функции, будет занимать определенное место в стеке. Очень часто при бесконечной рекурсии на JS можно встретить в консоли сообщение Maximum call stack size exceeded error. Оно говорит о том, что наш стек при последовательных вызовах функции попросту заполнился.*

### Куча
В отличие от стека куча не имеет ограничений по размеру и может увеличиваться при необходимости. В куче хранятся все не примитивные значения (массивы, хэш-таблицы, классы и так далее).

*В JS нам не нужно как-то управлять состоянием кучи, за нас это делает сборщик мусора. Однако в C++ его нет, поэтому программистам приходится самим управлять памятью своего приложения, это позволяет лучше поработать над оптимизацией, но при этом увеличивает нагрузку на разработчика и перекладывает на него все риски в виде утечек памяти.*

## WEB Api

У браузера есть Web API. Он является инструментом для отработки асинхронных функций в том числе, но помимо этого выполняет ряд задач для работы с DOM, картинками, аудио, видео, 3D-графикой. 

Нам интересна работа асинхронных функций. 

К ним относятся:
- Слушатели событий
- Promises
- SetTimeout
- XMLHttpRequest
- Fetch и многие другие

Когда код видит инструкции, связанные с обращением к WEB Api - он помещает инструкцию в стэк, исполняет ее. Если попадается инструкция, которую необходимо выполнить через WebApi - она туда помещается.

Так например:
- setTimeout поместиться в WebApi.
- WebApi запустит счетчик на отработку указанной задержки
- После выполнения задержки, коллбэк, который был заложен в метод setTimeout поместится в очередь задач (макрозадач), предоставляемый Event Loop'ом
- При пустом стеке - задача из очереди поместится в стек и будет выполена

*Будет выполнена первая задача из очереди, затем все последующие по принципу FIFO*

### Например, рассмотрим setTimeout

        console.log(1); // Сразу поместится в стек, выполнится

        setTimeout( // Отправится в WebApi на исполнение задержки 1 с.
            () => { // По истечению 1 с. поместит колбэк в очередь 
                // При пустом стеке - поместит колбэек в стек
                // Выполнится из стека, очистив его
                console.log('timeout');
            },
            1000
        );

        console.log(2); // Сразу поместится в стек, выполнится

Таким образом, порядок выполнения будет следующий:
1. 1
2. 2
3. timeout - спустя 1 секунду

### Слушатели событий

1. Регистрируем событие в WEB API

        button1.addEventListener('click', (event) => {
            console.log(event);
        });
2. При срабатывании события колбэк помещается в очередь
        (event) => {
            console.log(event);
        }
3. Event Loop ожидает пустой стэк вызовов, как только он очистился от других задач из стэка - помещает колбэк в стэк
4. Исполняет коллбэк, помещая содержимое колбэка в стэк
5. Исполняет содержимое колбэка, очищая свой контекст
6. Очищает контекст колбэка из стэка

## Promise

С помощью промисов мы можем запускать асинхронный код, который не будет блокировать основной поток.

## Очереди задач

У очередей есть определенный приоритет. Event Loop берет задачи в соответствие с ним. В первую очередь всегда выполняются Microtasks.

### Очередь событий - Macrotask queue

        setTimeout(() => {
            console.log('timeout');
        }, 0);

### Очередь задач - Microtask queue

`Promises` всегда попадают в очередь Microtask.

        Promise.resolve().then(() => {
            console.log('microtask');
        });

После того как выполнятся все синхронные функции, произойдет следующее:

- WebApi отработает задержку в 0 с, и поместит коллбэк в очередь `макрозадач`
- Promise будет находится в очереди `микрозадач`
- Сначала поместиться в стэк и выполнится микрозадача, а именно коллбэк, который передается в then
- Затем будет выполнена макрозадача - колбэк из setTimeout